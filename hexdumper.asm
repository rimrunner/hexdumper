

	;; assemble with nasm & ld:
	;; nasm -f elf hexdumper.asm 
	;; ld -m elf_i386 -o hexdumper hexdumper.o

	;; usage: ./hexdumper filename -a
	;; -a switch is optional and displays corresponding ASCII (only traditional 128 charset)
	
	%define	O_RDONLY	00 ;syötetään flags 0:na, mutta koodi on selkeämpää, kun siinä käyttää tuota flagsin kirjainmuotoa, joka siis vastaa nollaa
	
segment .data
	valil	db 32		 ;valilyönnin ASCII-arvo (dec.)
	rivinv	db 10		 ;rivinvaihdon ASCII-arvo (dec.)
	pviiva	db 124		 ;pystyviivan ASCII-arvo
	piste	db 46		 ;pisteen ASCII-arvo
	ei_loyd db 'Virhe: Tiedostoa ei löydy', 0
	len2	equ $ - ei_loyd
	ei_args db 'Virhe: Et antanut tiedoston nimeä', 0
	len     equ $ - ei_args

segment .bss
	;; Oleellista, että näissä muistipaikoissa ei ole sisällön koko vaan koko tulee sen mukaan, millaisilla rekistereillä niitä käytetään
	loppu	resb 1		;boolelainen muuttuja, joka kertoo, ollaanko luettavan tiedoston lopussa
	ascii	resb 1		;0 = asciit pois, 1 = asciit päällä, 2 = ollaan tekemässä viimeistä ascii-riviä
	vkount	resb 1		;kountteri välilyönneille, jotka tulee joka neljännelle tavulle
	rkount	resb 1		;kountteri riveille
	argm	resb 1		;argumenttien määrä

	fname	resd 1		;pointteri tiedostonnimeen osoittavaan argumenttiin
	buffer	resd 1		;tavun kokoinen bufferi, luetaan tiedostoa tavu kerrallaan
	fd	resd 1		;file descriptorin paikka, koko on double, koska vaikka FD itse on vain byten, muistipaikkaa operoidaan EAX:illä (32-bit = double)
	ekaa	resd 1		;ensimmäinen printattava heksa
	tokaa	resd 1		;toinen printattava heksa

	statbuf	resq 11		;88 tavua (11 quad wordia) on struct statin koko
	
segment .text
	global _start
_start:	
	;; ESP talteen ja EBP osoittamaan komentoriviargumentteja, ebp + 4 = argumentit
	push 	ebp		
	mov	ebp, esp
	cmp	dword [ebp + 4], 1
	jne	arg_loytyi
	;; jos ei argumentteja:
	mov     edx, len-1	;viestin pituus
	mov     ecx, ei_args	;itse viesti (pointteri)
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt
	jmp	lopetus

arg_loytyi:
	mov	eax, dword [ebp + 4]
	dec	eax 		;tähän tulee aina yhtä suurempi luku kuin mikä on argumentti, joten DEC
	mov	[argm], eax
	mov	edx, 3		;tästä kountteri käsitellyille argumenteille, vähennetään aina kaksi, niin on kountteriarvo, muuten lähdetään 3:sta, koska sillä osoitetaan ensimmäistä argumenttia
argloop:	
 	mov	eax, dword [ebp + 4 * edx] ;EAXiin ensimmäinen array-argumentti
	movzx	ebx, byte [eax] ;siitä ensimmäinen tavu EBX:ään
	cmp	ebx, 45		;onko tavun arvo -:n ASCII-koodi, jos ovat samat ZF on asetettu
	jz	sw_loytyi	;jos ZF päällä, haaraudu
	
	mov	[fname], eax 	;fnameen ensimmäisen elementin osoite argv:stä (joka on filename, jos tässä kohtaa ollaan)
	;; vähennetään EDX-kountterista - 2 ja verrataan argm:iin. Jos samat, looppi loppuu. Muuten kountteri kasvaa
	mov	eax, edx
	sub	eax, 2
	movzx	ecx, byte [argm]
	cmp	ecx, eax
	jz	sw_end
	add	edx, 1
	jmp	short argloop
	;; eax = edx-2, jos eax = argm, lopetetaan arg-looppi, muuten argloopin alkuun
sw_loytyi:
	movzx	ebx, byte [eax+1] ;siitä toinen tavu EBX:ään
	cmp	ebx, 97		  ;jos EBX on a:n ASCII-koodi
	jnz	sw_end		  ;jos ei ollut (ZF ei asetettu)
	mov	byte [ascii], 1	  ;[ascii] päälle, jos oli
	;; sama loopin loppu -kysely kuin edellä
	mov	eax, edx
	sub	eax, 2
	movzx	ecx, byte [argm]
	cmp	ecx, eax
	jz	sw_end
	add	edx, 1
	jmp	short argloop
sw_end:
	
	;; onko argumentti switch?
	mov     edx, 1	        ;viestin pituus
	mov	ecx, eax
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt
	
	;; muuttujien alustusta
	mov	byte [vkount], 0
	mov	byte [rkount], 0

	;; sys_stat, onko tiedosto olemassa
	mov	ebx, [fname]
	mov	ecx, statbuf
	mov	eax, 18
	int	0x80

	mov	ebx, -75	; jostain syystä syscallin onnistunut kutsu palauttaakin EAX:ään -75
	cmp	eax, ebx	
	jnz	eitied		; lopetetaan, jos tiedostoa ei löydy
	
	;; sys_open, avataan tiedosto
	mov	ebx, [fname]	; EBX:ään syscallin ensimmäinen argumentti
	mov	ecx, O_RDONLY	; syscallin toinen argumentti
	mov	eax, 5		; 5 = sys_openin numero
	int	0x80		; keskeytys 0x80 (128) kutsuu syscallin, jonka numero otetaan EAXista
	mov	[fd], eax	; sys_call palauttaa file descriptorin EAX:aan ja se laitetaan sille kuuluvalle paikalleen
	
lukeminen:	
	;; sys_read, luetaan
	mov	ebx, [fd]	; FD argumentiksi
	mov	ecx, buffer	; bufferin osoite argumentiksi
	mov	edx, 1		; size_t count -argumentti eli paljonko luetaan
	mov	eax, 3		; sys_readin numero EAX:ään
	int	0x80

	;; ollaanko jo tiedoston lopussa
	mov	ebx, 0
	cmp	eax, ebx	; jos sys_read palauttaa nollan EAX:ään, ollaan tiedoston lopussa
	jnz	ei_lopu		; CMP laittaa ZF:n päälle, jos numerot ovat samat, jos se ei ole päällä, hypätään jatkoon
	;; jos ascii on päällä, tehdään vielä viimeinen ascii-rivi
	mov	al, 1
	cmp	al, [ascii]
	jz	vika_arivi
	;; jos ascii = 2 eli ollaan tekemässä vikaa ascii-riviä, laitetaan loppuun vielä pystyviiva
	mov	al, 2
	cmp	al, [ascii]
	jnz	lopetus
	mov     edx, 1	        ;viestin pituus
	mov     ecx, pviiva
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt
	jmp 	lopetus
ei_lopu:
	;; ollaanko kirjoittamassa ASCIIta (jos rkount on yli 15)
	mov	bl, 15
	cmp	bl, [rkount]
	jc	k_ascii
	
	;; vertailut alkaa
	;; Onko bufferissa oleva arvo alle 16?
	mov	ebx, 15
	cmp	ebx, [buffer]	;jos vasen on pienempi, CF päälle, ZF pois
	jc	suurempi	;EBX pienempi eli luku yli 16 ja hypätään
	mov	byte [ekaa], 48	;Kun ensimmäinen heksa ei ole käytössä, siihen voi laittaa suoraan nollan (eli 48 ASCIIna)
	movzx	edx, byte [buffer] ;Tämä on erittäin tärkeä. Pelkkä MOV jättää EDX:ään satunnaisia arvoja ("bufferista"), MOVZX nollaa sen
	call 	konversio	;laittaa stackiin seuraavan rivin osoitteen
	mov	[tokaa], edx
	jmp	short vertloppu
suurempi:			;Jos arvo on yli 15
	xor	edx, edx	;DIV jakaa EDX:EAX:n operaattorilla, joten tämän voisi XORrata varmuuden vuoksi
	movzx	eax, byte [buffer]
	mov	ebx, 16
	div	ebx		;Jakaa 32-bittisen -> osamäärä (ensimmäinen heksaluku) menee EAX:ään ja jakojäännös (toinen heksaluku) EDX:ään
	call	konversio	;Konversio käyttää EDX:ää, jonne jakojäännös meni, joten hoidetaan ensin toinen heksaluku
	mov	[tokaa], edx
	mov	edx, eax   	;Osamäärä on EAX:ssä, joten nyt se EDX:ään konversiota varten
	call 	konversio	;laittaa stackiin seuraavan rivin osoitteen stackiin
	mov	[ekaa], edx
	jmp	short vertloppu
konversio:			;tämä kohta muuttaa 0-15 desimaaliarvon heksan ASCII-arvoksi, EDX:ssä on se arvo, mikä konvertoidaan
	mov	ebx, 9
	cmp	ebx, edx	;jos vasen arvo on pienempi (eli arvo on suurempi kuin 9), ZF on pois päältä ja CF on päällä
	jc	yliysi		;jc hyppää, vain jos CF on päällä (muut CMP:n tulokset eivät laita CF:ää päälle)
	add	edx, 48		;kun lisätään 0-9 -kokoiseen arvoon 48, tulee ASCIIn 0-9 (48-57)
	ret			;palaa sinne, mistä on tultu (stackissa pitää olla ilmeisesti päällimmäisenä se)
yliysi:	
	add	edx, 55		;Kun lisätään kymmenlukuihin 10-15 luku 55, saadaan ASCII-arvot A-F (65-70)
	ret			

vertloppu:	
	;; Heksojen printtaus
	mov     edx, 1	        ;viestin pituus
	mov     ecx, ekaa	;itse viesti (pointteri)
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
 	int     0x80            ;int = software interrupt
	
	mov     ecx, tokaa	;itse viesti (pointteri)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt
	inc	byte [rkount]
	;; vkountin nollaus ja välilyönnin printtaus tuleekin samaan aikaan. Jos vkount on 1 -> printtaa ja nollaa
	inc	byte [vkount]
	mov	bl, 1
	cmp	bl, [vkount]
	jc	valprint
	jmp	lukeminen
valprint:	
	mov	byte [vkount], 0
	mov     edx, 1	        ;viestin pituus
	mov     ecx, valil	;itse viesti (pointteri)
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt

	;; vaihtuuko rivi
	mov	bl, 15
	cmp	bl, [rkount]
	jc	a_vai_v
	jmp	lukeminen
a_vai_v:
	;; ASCIIta vai rivinvaihtoa
	mov	al, 1
	cmp	al, [ascii]
	jnz	vaihto
	jmp	short k_ascii
vaihto:	
	call	rivinvaihto
	jmp 	lukeminen
k_ascii:
	;; tässä pitää tehdä uusi rivinvaihdon tarkistus
	;; sitten katsotaan se ascii-arvo ...pitääkö käyttää lseekiä vai pitääkö nämä ASCIIt lukea aiemmin
	;; jos rkount on ensimmäisessä ascii-merkissä, niin lseek rivin alkuun. jos taas lopussa, kelataan se seuraavalle riville
	mov	bl, 16		;8 on ilmeisesti ensimmäinen ASCII-arvo
	cmp	bl, [rkount]
	jc	ei_eka		;jos ei ole samat, ei olla ensimmäisessä ASCII-arvossa
	;; jos ollaan ensimmäisessä ASCII-arvossa, sitten printataan myös välilyönti ja pystyviiva, siirretään lseek-offsettia ja lopuksi merkinkirjoituskohtaan

	mov	ebx, [fd]
	mov	ecx, -16     	;offset
	mov	edx, 1		;1 = SEEK_CUR = aloitetaan nykyisestä kohdasta
	mov     eax, 19         ;19 = lseek
	int     0x80
k_ascii2:	
	;; Tähän väliin sysread, samanlainen oli aiemminkin
	mov	ebx, [fd]	; FD argumentiksi
	mov	ecx, buffer	; bufferin osoite argumentiksi
	mov	edx, 1		; size_t count -argumentti eli paljonko luetaan
	mov	eax, 3		; sys_readin numero EAX:ään
	int	0x80

	mov     edx, 1	        ;välilyönnin printtaus, esiintyy aiemminkin koodissa
	mov     ecx, valil
	mov     ebx, 1
	mov     eax, 4
	int     0x80

	mov     edx, 1	        ;viestin pituus
	mov     ecx, pviiva
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt

	jmp	as_vai_ps

ei_eka:
	;; ollaanko jo viimeisen kohdan yli?
	mov	bl, 31		;oli 24
	cmp	bl, [rkount]
	jnc	as_vai_ps

	;; rivin loppuun tuleva pystyviiva
	mov     edx, 1	        ;viestin pituus
	mov     ecx, pviiva
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt

	;; ollaanko lopussa

	mov	al, 2
	cmp	al, [ascii]
	jz	lopetus
	;; lseekin palautus
	mov	ebx, [fd]
	mov	ecx, -1
	mov	edx, 1
	mov     eax, 19
	int     0x80

	call	rivinvaihto
	jmp	lukeminen

as_vai_ps:
	;; sen jälkeen kysytään, onko arvo yli 127. jos kyllä, piirretään piste, muuten asciin piirtoon
	inc	byte [rkount]
	mov	ebx, 126
	cmp	ebx, [buffer]	;jos vasen on pienempi, CF päälle, ZF pois
	jc	kpiste		;EBX pienempi eli luku yli 127 ja hypätään

	mov	ebx, 31
	cmp	[buffer], ebx
	jc	kpiste		
	;; printataan ASCII
	mov     edx, 1	        
	mov     ecx, buffer
	mov     ebx, 1          
	mov     eax, 4          
	int     0x80
	jmp	lukeminen

kpiste:
	mov     edx, 1	        
	mov     ecx, piste
	mov     ebx, 1          
	mov     eax, 4          
	int     0x80            
	jmp	lukeminen
	
rivinvaihto:
	mov 	edx, 1
	mov	ebx, 1		;fd (stdout)
	mov	eax, 4
	mov	ecx, rivinv
	int	0x80		
	mov	byte [rkount], 0
	ret

vika_arivi:			;viimeinen ascii-rivi
	mov	byte [ascii], 2	;merkiksi, että lopetetaan tämän rivin jälkeen

	;; Jos heksarivi on täyspitkä, ei tarvitse lisäillä mitään välilyöntejä enää:
	mov	bl, 32
	cmp	bl, [rkount]
	jz	lukeminen

	;; välilyöntien lisäys ennen ASCII-riviä viimeisen heksa-rivin lyhyemmän pituuden takia
	mov	byte [vkount], 1 ;samaa vkount-muuttujaa voi käyttää tässä, arvo 1, koska juuri ennen pystyviivaa tulee aina ylimääräinen välilyönti
	mov	al, [rkount]
	mov	bl, 16
	sub	bl, al		;16 - rkount, saadaan montako rkountia puuttuu täydestä rivistä
	movzx	ax, [rkount]	;DIV jakaa AX:n (jos operandi on 8-bittinen)
	mov	cl, 2
	div	cl		;osamäärä AL:ään ja jakojäännös AH:hon
	cmp	ah, 0		;jos jakojäännös 0, luku on parillinen
	jz	paril		;jos parillinen
	add	byte [vkount], 2
	sub	bl, 1
	jmp	short jatko
paril:
	add	byte [vkount], 4
	sub	bl, 2
jatko:
	movzx	ax, bl		;muunneltu p-rkount ax:ään
	div	cl		;jaetaan taas kahdella
	mov	bl, al		;siirretään, koska AL/AX/EAX käytetään MULissa
	mov	al, 5		;MUL kertoo tavun kokoiset AL:llä
	mul	bl		;tulos DX:AX:ään
	;; (LOOP-käsky ei onnistu, koska se käyttää ECX:ää, jota tarvitaan loopissa syscalliin)
	;; myös EBX:ää käytetään, joten AL pitäisi siirtää esim. vkountiin:
	add	byte [vkount], al ;ei tarvitse muuntaa erikseen AX:ää AL:ksi, se on jo siellä jos se kerran mahtuu AL:ään
looppi:
	mov     edx, 1	        ;viestin pituus
	mov     ecx, valil	;itse viesti (pointteri)
	mov     ebx, 1          ;file descriptor (stdout)
	mov     eax, 4          ;system call number (sys_write)
	int     0x80            ;int = software interrupt
	dec	byte [vkount]
	mov	al, 0
	cmp	[vkount], al
	jnz	looppi
	movzx	ecx, byte [rkount]
	neg	ecx
	mov	ebx, [fd]
	mov	edx, 1		;1 = SEEK_CUR = aloitetaan nykyisestä kohdasta
	mov     eax, 19         ;19 = lseek
	int     0x80
	mov	byte [rkount], 16
	jmp	k_ascii2

eitied:	
	mov     edx, len2-1	
	mov     ecx, ei_loyd	
	mov     ebx, 1          
	mov     eax, 4          
	int     0x80            
	
lopetus:	
	call	rivinvaihto	
	mov	eax, 1		; exit-syscall
	int 	0x80
